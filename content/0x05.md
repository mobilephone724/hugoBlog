---
title: "0x05"
date: 2024-07-07T15:53:54+08:00
math: true
---

## 0x0 backgroud

Even though ARIES simplifies the recovery process and allows it to be generic for all transactional operations, **recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions** which makes the cost of recovery proportional to the work performed by these transactions. This significantly impacts database availability since **recovering a long running transaction can take several hours**.

This paper describes the overall design of “**Constant Time Recovery**” (CTR) 

**Recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions, and recovering a long running transaction can take several hours**

## **0x1 BACKGROUND ON SQL SERVER**

### **0x11 DatabaseRecovery**

**Following ARIES**, the SQL Server recovery process has three distinct phases. Figure 2 demonstrates these phases and the portion of the log they process.

![image-20240707155547821](./assets/image-20240707155547821.png)

(The oldest transaction can run across many checkpoints)

- analysis: identifys:
    - any transactions that must be rolled back
    - LSN of the oldest dirty page in the system
        - Checkpoint process captured all active transactions and the oldest dirty page LSN at the time of the checkpoint, so analysis can start from that
- redo: **bringing the database back to the state it was at the time of the failure:**
    - Since Analysis has recomputed the **Oldest Dirty Page LSN**, Redo should only process the log from this point.
        - Only applies the operation if the Page LSN is lower
    - Processes the log starting from the beginning of the **oldest active transaction**.
        - This allows recovery to **reacquire all the locks held by active transactions** and make the database **available at the end of Redo for improved availability**
- undo: **rolling back any transactions that were active at the time of the failure.**
    - As Redo has reacquired the locks required by these transactions, the Undo process can be performed while the database is available and user queries will be blocked only **if they attempt to access the data modified by the transactions pending undo**.
    - Undoing these operations is also logged using Compensation Log Records (**CLR**) to guarantee that the database is recoverable even after a failure in the middle of the Undo process

### **0x12 Multi-versionConcurrencyControl**

Versioning is performed at the row level: for every user data update, **SQL Server updates the row in-place in the data page and pushes the old version of the row to an append-only version store**, linking the current row version to the previous version

The versions are linked to each other using their physical locator

![image-20240707155610090](./assets/image-20240707155610090.png)

Given that these versions are only used for the purposes of SI, the version store doesn’t need to be preserved across restarts and is stored in SQL Server’s “TempDB”, a system database that is recycled every time the SQL Server process restarts. This allows for efficient version generation, as these operations are not logged.

## **0x2 CONSTANTTIMERECOVERY**

### 0x21 **Overview**

- Database recovery in constant time, regardless of the user workload and transaction sizes.
- Transaction rollback in constant time regardless of the transaction size.
- Continuous transaction log truncation, even in the presence of long running transactions.

CTR achieves these by separating transactional operations into three distinct categories and handling their recovery using the most appropriate mechanism.

### 0x22 three transactional operations categories

#### 0x221 Data Modifications

All data modifications are versioned, storing the earlier versions of each row in **the version store that is now redesigned to be persistent and recoverable**

（笑死我了，刚刚还在感叹 version store 无需记录，重启即删多么方便）

When a transaction rolls back, it is simply marked as “aborted”, indicating that any new transactions should ignore the versions generated by this transaction and access the earlier committed versions

During database recovery

- Analysis identifies the state of every transaction
- **Redo recovers the row and the version store** content as of the time of the failure.
- **Undo marks the uncommitted transactions as aborted** making all updates by these
  transactions invisible.
    - This allows Undo to complete in constant time, regardless of the transaction sizes.
    - （仍然和 aborted xact count 相关，但相比于 modified row count，几乎可以忽略不计）

#### 0x222 System Operations

System operations refer to internal operations the DBMS uses to maintain its internal data structures, such as space allocation and deallocation, B-Tree page splits, etc.

- difficulty:
    - These operations cannot be easily versioned
    - Additionally, these operations are usually tied to user data modifications and can be a significant percentage of the operations performed by a long-running transaction.
        - For example, a large data load allocates a large number of pages
- Solution:
    - These operations are always performed by short-lived, system transactions that update the internal data structures and immediately commit
    - **When a failure occurs, these operations will not be undone, but the allocated space and other updated data structures will be lazily reclaimed and fixed up in the background.**

#### 0x223 Logical and Other Non-versioned Operations

This last category refers to operations that cannot be versioned because they are either:

- logical: such as
    - **lock acquisition** operations that indicate that a certain lock must be acquired during recovery
    - **cache invalidation** operations that are responsible for invalidating in-memory caches when a transaction rolls back
- they are **modifying data structures that need to be accessed during start up**
    - must maintain a very specific format that does not allow versioning

CTR leverages an additional log stream, **SLog**, that allows tracking only the relevant operations and not having to process the full transaction log for the corresponding transactions.

### 0x23 Persistent Version Store

Persistent Version Store (PVS) versions contain the same data and are chained in the same way as the ones stored in TempDB. However, since they are recoverable, they can be used for accessing earlier versions of each row after a failure.  Hence, **at the end of Redo all versions are fully recovered and can be accessed by user transactions**.

In CTR, versions are needed for recovery purposes and have to be preserved until the committed version of each row has been brought back to the data page.

#### 0x231 In-row Version Store

The in-row version store is an optimization that **allows the earlier version of a row to be stored together with the latest version in the main data page**.

- we can simply store the diff between the two versions
- Even though computing and reapplying the diff requires additional CPU cycles,  **the cost of generating an off-row version, by accessing another page and logging the version as a separate operation, is significantly higher**

This makes in-row versioning a great solution

- reducing the storage overhead
- reducing the cost for logging the generated version, as
  - effectively log the version together with the data modification
  - we only increase the log generated by the size of the diff

![image-20240707162741690](./assets/image-20240707162741690.png)

（当修改时，row 的长度会变化？不预留空间：如何确保位置不移动？；预留空间：预留多少？）

Despite its benefits in most common cases, **in-row versioning can negatively impact the performance of the system if it significantly increases the size of rows in the data pages**

- To mitigate this issue, the size of in-row versions **is capped both in terms of the size of the diff**, as well as the **size of the row** it can be applied to. 
- When these exceed certain thresholds, PVS will fall back to generating **off-row versions**, on a different page.



#### 0x231 Off-row Version Store

Each database has a single off-row PVS table that maintains the versions for all user tables in the database. Each version of user data is stored as a separate row in this table
